Advance Topics:
React:
---------------------------------------------------------------------------------------------------
1PWA:https://medium.com/@toricpope/transform-a-react-app-into-a-progressive-web-app-pwa-dea336bd96e6
2:Asyncronous updates on with websocket
3:Robot.txt in react folder structured
4:Npm Package https://www.freecodecamp.org/news/how-to-create-and-publish-your-first-npm-package/
5:PersistantGate,ApplicationInsights,persistReducer :
                     https://github.com/rt2zz/redux-persist/blob/master/docs/PersistGate.md
                     https://betterprogramming.pub/implementing-react-redux-store-with-persistence-44a030bbbf94#:~:text=The%20persistReducer%20method%20allows%20us,the%20store%20will%20be%20persisted.
6:Webpack:https://www.scaler.com/topics/react/webpack-in-react/
		 :HtmlWebpackPlugin
7:Publish React Component As Npm Package:https://levelup.gitconnected.com/publish-react-components-as-an-npm-package-7a671a2fb7f
8:Lazy Loading:https://react.dev/reference/react/lazy
9:Advance Guide React:https://legacy.reactjs.org/docs/accessibility.html
10:Error Boundaries :https://legacy.reactjs.org/docs/error-boundaries.html
11:Convert App intoPwa:https://medium.com/@toricpope/transform-a-react-app-into-a-progressive-web-app-pwa-dea336bd96e6
12:When build is not Build:https://create-react-app.dev/docs/deployment/
13:React hogher order component:https://www.smashingmagazine.com/2020/06/higher-order-components-react/
14:React helmet for seo
	https://medium.com/@franklynugege/seo-in-react-two-simple-step-implementation-7d9382381718
	https://www.freecodecamp.org/news/react-helmet-examples/
15Fiber:https://github.com/acdlite/react-fiber-architecture   - reconceilation

16React 18 Feture :https://www.acil.in/what-new-in-react-18/


----------------------------------------------------------------------------------------------------------



NextJs
-------------------------------------------------------------------------------------------------------
Notes: Run dev server ->npm run dev /Run production:npm start
1Deploy Next js On Vercel:https://www.youtube.com/watch?v=2HBIzEx6IZA
2Crud Operation:https://www.youtube.com/watch?v=kuV_iAIDT5Y
3Build-a-full-stack-application-with-nextjs :https://www.freecodecamp.org/news/build-a-full-stack-application-with-nextjs/
4REST Api:https://www.youtube.com/watch?v=-MFiza7ZRzs
5:Next Js BackEnd:https://medium.com/@oruchan.asar/nextjs-13-app-backend-development-d044c804c3
6:RestApi:https://jasonwatmore.com/post/2021/08/31/next-js-combined-add-edit-create-update-form-example
7:Use Swr:https://swr.vercel.app/docs/with-nextjs - For data fatching
8:Nextjs Auth with 13:https://medium.com/ascentic-technology/authentication-with-next-js-13-and-next-auth-9c69d55d6bfd
9: optimize 3rdf party script:https://nextjs.org/docs/pages/building-your-application/optimizing/scripts
Cache issue
https://www.youtube.com/watch?v=3RyguimNe8s&t=697s
export const dynamic = "force-dynamic"
-Next.js is a flexible React framework that gives you building blocks to create fast web applications.
-CSR,SSR,SSG
-Imperative & Declarative Programming:
									The code above is a good example of imperative programming. You’re writing the steps for how the user interface should be updated. 
									But when it comes to building user interfaces, a declarative approach is often preferred because it can speed up the development process. 
									Instead of having to write DOM methods, it would be helpful if developers were able to declare what they want to 
									show (in this case, an h1 tag with some text).In other words,  programming is like giving a chef step-by-step instructions on 
									how to make a pizza. Declarative programming is like ordering a pizza without being concerned about the steps it takes to make the pizza. 🍕
The environment where your code runs: Development vs. Production
When your code runs: Build Time vs. Runtime
Where rendering happens: Client vs. Server
-Minification:
				Minification is the process of removing unnecessary code formatting and comments without changing the code’s functionality. 
				The goal is to improve the application’s performance by decreasing file sizes.
-What is Compiling?
					Developers write code in languages that are more developer-friendly such as JSX, TypeScript, and modern versions of JavaScript. 
					While these languages improve the efficiency and confidence of developers, they need to be compiled into JavaScript before browsers can understand them.
-client-side rendering:
					React application, the browser receives an empty HTML shell from the server along with the JavaScript instructions to construct the UI. 
					This is called client-side rendering because the initial rendering work happens on the user's device.
-Bundling:
		Bundling is the process of resolving the web of dependencies and merging (or ‘packaging’) the files (or modules) into optimized bundles for the browser, 
		with the goal of reducing the number of requests for files when a user visits a web page.
-What is the difference between compiling and bundling in web development?
																		Compiling is transforming code into something parsable by browsers. 
																		Bundling is resolving your applications dependency graph and reducing the number of files
Some Concepts:
-Routing as folder
-each folder has page.js file.
-The useRouter hook allows you to programmatically change routes.
-This hook can only be used inside Client Components and is imported from next/navigation.
-The useRouter hook allows you to programmatically change routes.
-This hook can only be used inside Client Components and is imported from next/navigation.
-NextResponse:The NextResponse API allows you to:Redirect the incoming request to a different URL
												 Rewrite the response by displaying a given URL
												 Set request headers for API Routes, getServerSideProps, and rewrite destinations
												 Set response cookies
												 Set response headers
												 Fetching data after some time  time based/ondemand  Revalidation
												 React renders Server Components into a special data format called the React Server Component Payload (RSC Payload).

Static Site Generation (SSG): 
							Static Generation is a server-side rendering method where Next.js generates HTML at build time. 
							During the build process, Next.js fetches data from APIs or other data sources and pre-renders the HTML pages. 
							These pre-rendered pages can then be served to the client upon request. SSG is suitable for websites with content that doesn't frequently change.
Server-Side Rendering (SSR): 
							Server-Side Rendering is another method where Next.js generates HTML on each request.
							When a user visits a page, Next.js fetches the data and renders the HTML on the server before sending it to the client. 
							SSR is useful for websites with frequently updated content or personalized user experiences.
Incremental Static Regeneration (ISR): 
										ISR is a feature in Next.js that allows you to statically generate pages on-demand, rather than at build time. 
										This means that your site can be both statically generated and dynamic at the same time.
SWR:The team behind Next.js has created a React hook for data fetching called SWR. 
	We highly recommend it if you’re fetching data on the client side. It handles caching, revalidation, focus tracking, refetching on interval, and more. 
	We won’t cover the details here, but here’s an example usage:


												 
-folder->page.tsx is used for routing
-component like is not use for routing like add to cart button

Nextjs:https://www.youtube.com/watch?v=OgS1ZWZItno&list=PLu71SKxNbfoBAaWGtn9GA2PTw0HO0tXzq
Next auth :https://www.youtube.com/watch?v=3BEn2E9PvBM&list=PLu71SKxNbfoCXO80Z4miZHTL5GxfFbz7A
Backend series:https://www.youtube.com/watch?v=EH3vGeqeIAo&list=PLu71SKxNbfoBGh_8p_NS-ZAh6v7HhYqHW&pp=iAQB
Shared folder:https://medium.com/capriza-engineering/sharing-source-code-and-libraries-in-react-bd30926df312
---------------------------------------------------------------------------------------------------------
with return keyword in map
const names = characters.map((character) ⇒ { return character.name;
});

without return 
const minified Records = characters.map((character) ⇒ (//thisbracket show as return object 
{
name: character.name,
height: character.height,
}));


---------------------------

          setUnreadMessages((prevUnreadMessages) => {       
            const receiverMessages = prevUnreadMessages[id] || {};
            const currentCount = senderId ? receiverMessages[senderId] || 0 : 0; 
   
            return {
              ...prevUnreadMessages,
              [id]: {
                ...receiverMessages,
                [senderId as string]: currentCount + 1,
              },
            };
          });
        });
	
	  setUnreadMessages((prevUnreadMessages) THIS LINE GIVES MOST RECENT UPDATE STATE
	  return {
              ...prevUnreadMessages,
              [id]:  this remain previous state as it is only update or create filed which is id
----------------------------------------------------------



React with TypeScript


1. Ensure Proper Typing for State and Props
	State and Props: Every component’s state and props need to be typed. 
	This is one of the most crucial parts of a TypeScript React project.

	// Example: Typing the props and state for a functional component
	interface MyComponentProps {
	  title: string;
	}

	interface MyComponentState {
	  count: number;
	}

	const MyComponent: React.FC<MyComponentProps> = ({ title }) => {
	  const [count, setCount] = useState<MyComponentState['count']>(0);

	  return (
		<div>
		  <h1>{title}</h1>
		  <button onClick={() => setCount(count + 1)}>{count}</button>
		</div>
	  );
	};
useState with TypeScript: Ensure that hooks like useState are typed correctly, 
particularly when dealing with objects or complex structures.

2. Handling Event Types

When using event handlers like onClick, onChange, or other DOM events, 
TypeScript requires you to specify the event type. For example:

	const handleClick = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
	  console.log("Button clicked");
	};
	This ensures you're working with the correct types and prevents runtime errors.

3. Use React.FC (Functional Components) for Typing Components
	You can use the React.FC (Function Component) type for your components to 
	automatically infer the return type and children types. However, keep in mind that React.FC can
	 sometimes be overly restrictive, especially when you don’t want to use the children prop, 
	 so be selective in its usage.


		const MyComponent: React.FC = () => {
		  return <div>Hello, TypeScript!</div>;
		};
		
		If you don’t want to include children, you might need to use a more explicit typing approach:
		
		const MyComponent = (props: MyComponentProps) => {
		  return <div>{props.title}</div>;
		};
		
4. Component Defaults

	TypeScript also ensures that you have correctly defined defaults for props.

	const MyComponent = ({ title }: { title?: string }) => {
	  const defaultTitle = title || "Default Title"; // You can have defaults
	  return <h1>{defaultTitle}</h1>;
	};
	
5. Optional Chaining and Nullish Coalescing
	TypeScript 3.7+ supports optional chaining and nullish coalescing, 
	which you can use to safely access nested properties:

	const name = user?.profile?.name ?? "Guest";
	
	This helps in cases where a property might be null or undefined, 
	ensuring safe navigation through deeply nested objects.

6. Using any and Avoiding it
	While any can be used as a last resort, TypeScript’s strength lies in strong typing, 
	and any defeats this purpose. Avoid using any unless absolutely necessary. Instead, 
	use more specific types (e.g., unknown, Record<string, any>, etc.).

	// Avoid this:
	const data: any = fetchData();

	// Use more specific types:
	const data: MyDataType = fetchData();
	
7. TypeScript with Context API
	When using the Context API, you need to type both the context provider and the consumer properly:

	interface AppContextType {
	  user: string;
	  isLoggedIn: boolean;
	}

	const AppContext = React.createContext<AppContextType | undefined>(undefined);

	const AppProvider: React.FC = ({ children }) => {
	  const [user, setUser] = useState<string>('John Doe');
	  const [isLoggedIn, setIsLoggedIn] = useState<boolean>(false);

	  return (
		<AppContext.Provider value={{ user, isLoggedIn }}>
		  {children}
		</AppContext.Provider>
	  );
	};

	const useAppContext = () => {
	  const context = useContext(AppContext);
	  if (!context) throw new Error('useAppContext must be used within AppProvider');
	  return context;
	};
	
8. TypeScript with Redux
	When using Redux, you'll need to type actions, reducers, and state:

Actions:
	interface AddUserAction {
	  type: "ADD_USER";
	  payload: { name: string; age: number };
	}

	type UserActions = AddUserAction;

	const addUser = (user: { name: string; age: number }): AddUserAction => ({
	  type: "ADD_USER",
	  payload: user,
	});
	
Reducers:
	interface UserState {
	  name: string;
	  age: number;
	}

	const initialState: UserState = {
	  name: '',
	  age: 0,
	};

	const userReducer = (state = initialState, action: UserActions): UserState => {
	  switch (action.type) {
		case "ADD_USER":
		  return { ...state, ...action.payload };
		default:
		  return state;
	  }
	};
	
Dispatch:
	const dispatch = useDispatch();
	dispatch(addUser({ name: 'John Doe', age: 30 }));
	
9. Using enum for Stronger Type Control
	Enums are a great way to represent a set of constants, such as status codes, action types, etc. 
	TypeScript will enforce the types of these constants.

	enum Status {
	  Success = 'success',
	  Error = 'error',
	}

	const handleStatus = (status: Status) => {
	  if (status === Status.Success) {
		console.log('Operation was successful');
	  }
	};
	
10. Asynchronous Code with TypeScript
	When working with asynchronous code (e.g., using async/await), you
	 should type the return values of the promises and any associated variables.

	const fetchData = async (): Promise<MyDataType> => {
	  const response = await fetch('api/data');
	  const data = await response.json();
	  return data;
	};
	
	This ensures that TypeScript knows exactly what type fetchData will return, helping to avoid runtime errors.

11. Type Assertion

	Sometimes, TypeScript can't infer the type of a variable, especially when working with 
	dynamic data (e.g., data from an API). In such cases, you can use type assertion to tell 
	TypeScript what the type should be:


	const value = someValue as string;
	
	While this can be useful in some situations, it should be used sparingly as it bypasses type safety.

12. Types for External Libraries
	If you're using external libraries that don’t provide TypeScript definitions, 
	consider installing type definitions from DefinitelyTyped.


	npm install --save-dev @types/library-name
If no types are available, you can define the types yourself.


1. Union Types in React
	Union types allow a prop to accept multiple types. For example, a Button component 
	that can accept both string and JSX as children:

	import React from 'react';

	type ButtonProps = {
	  children: string | JSX.Element;
	  onClick: () => void;
	};

	const Button: React.FC<ButtonProps> = ({ children, onClick }) => {
	  return <button onClick={onClick}>{children}</button>;
	};

	export const App = () => {
	  return (
		<div>
		  <Button onClick={() => alert('Clicked!')}>Click Me</Button>
		  <Button onClick={() => alert('Clicked!')}>
			<strong>Click Me Strong</strong>
		  </Button>
		</div>
	  );
	};
In this example, the children prop can either be a string or a JSX.Element. 
This demonstrates how Union Types can be used to allow multiple possible types.

2. Intersection Types in React

Intersection types allow combining multiple props from different interfaces. 
For example, a UserProfile component that needs both User and Address details:

tsx
Copy code
import React from 'react';

interface User {
  name: string;
  age: number;
}

interface Address {
  city: string;
  country: string;
}

type UserProfileProps = User & Address;

const UserProfile: React.FC<UserProfileProps> = ({ name, age, city, country }) => {
  return (
    <div>
      <h1>{name}</h1>
      <p>Age: {age}</p>
      <p>City: {city}</p>
      <p>Country: {country}</p>
    </div>
  );
};

export const App = () => {
  return (
    <UserProfile
      name="Alice"
      age={30}
      city="New York"
      country="USA"
    />
  );
};
In this example, the UserProfileProps type is an intersection of the User and Address interfaces. 
The UserProfile component needs to have both user information and address information.

3. Mapped Types in React
Mapped types allow transforming existing types. 
For instance, if you want to make all props of a component optional:

	import React from 'react';

	type ComponentProps = {
	  title: string;
	  description: string;
	  isActive: boolean;
	};

	type OptionalProps<T> = {
	  [K in keyof T]?: T[K];
	};

	type OptionalComponentProps = OptionalProps<ComponentProps>;

	const Component: React.FC<OptionalComponentProps> = ({ title, description, isActive }) => {
	  return (
		<div>
		  <h1>{title}</h1>
		  <p>{description}</p>
		  <p>{isActive ? 'Active' : 'Inactive'}</p>
		</div>
	  );
	};

	export const App = () => {
	  return (
		<div>
		  <Component title="Hello" description="This is a component" isActive={true} />
		  <Component title="Only Title" />
		</div>
	  );
	};
Here, OptionalProps is a mapped type that makes all properties of ComponentProps optional.
 The Component can now accept partial props, making it more flexible.
 

Here's how you can use Union Types, Intersection Types, Mapped Types, Conditional Types, and Generics in real-time React projects:

1. Union Types in React
Union types allow a prop to accept multiple types. For example, a Button component that can accept both string and JSX as children:

tsx
Copy code
import React from 'react';

type ButtonProps = {
  children: string | JSX.Element;
  onClick: () => void;
};

const Button: React.FC<ButtonProps> = ({ children, onClick }) => {
  return <button onClick={onClick}>{children}</button>;
};

export const App = () => {
  return (
    <div>
      <Button onClick={() => alert('Clicked!')}>Click Me</Button>
      <Button onClick={() => alert('Clicked!')}>
        <strong>Click Me Strong</strong>
      </Button>
    </div>
  );
};
In this example, the children prop can either be a string or a JSX.Element. This demonstrates how Union Types can be used to allow multiple possible types.

2. Intersection Types in React
Intersection types allow combining multiple props from different interfaces. For example, a UserProfile component that needs both User and Address details:

tsx
Copy code
import React from 'react';

interface User {
  name: string;
  age: number;
}

interface Address {
  city: string;
  country: string;
}

type UserProfileProps = User & Address;

const UserProfile: React.FC<UserProfileProps> = ({ name, age, city, country }) => {
  return (
    <div>
      <h1>{name}</h1>
      <p>Age: {age}</p>
      <p>City: {city}</p>
      <p>Country: {country}</p>
    </div>
  );
};

export const App = () => {
  return (
    <UserProfile
      name="Alice"
      age={30}
      city="New York"
      country="USA"
    />
  );
};
In this example, the UserProfileProps type is an intersection of the User and Address interfaces. The UserProfile component needs to have both user information and address information.

3. Mapped Types in React
Mapped types allow transforming existing types. For instance, if you want to make all props of a component optional:

tsx
Copy code
import React from 'react';

type ComponentProps = {
  title: string;
  description: string;
  isActive: boolean;
};

type OptionalProps<T> = {
  [K in keyof T]?: T[K];
};

type OptionalComponentProps = OptionalProps<ComponentProps>;

const Component: React.FC<OptionalComponentProps> = ({ title, description, isActive }) => {
  return (
    <div>
      <h1>{title}</h1>
      <p>{description}</p>
      <p>{isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
};

export const App = () => {
  return (
    <div>
      <Component title="Hello" description="This is a component" isActive={true} />
      <Component title="Only Title" />
    </div>
  );
};
Here, OptionalProps is a mapped type that makes all properties of ComponentProps optional. The Component can now accept partial props, making it more flexible.

4. Conditional Types in React
Conditional types can be used for prop validation based on conditions.
 For example, you can create a Status component that behaves differently depending on whether the status is a string or a boolean:

import React from 'react';

type StatusProps<T> = T extends boolean ? { active: T } : { message: T };

const Status: React.FC<StatusProps<string | boolean>> = (props) => {
  if (typeof props.active === 'boolean') {
    return <div>{props.active ? 'Active' : 'Inactive'}</div>;
  }
  return <div>{props.message}</div>;
};

export const App = () => {
  return (
    <div>
      <Status active={true} />
      <Status message="Service is down" />
    </div>
  );
};
In this example, StatusProps is a conditional type that checks whether T is a boolean or a string. 
If T is a boolean, it expects an active prop; if it's a string, it expects a message prop.
 This demonstrates Conditional Types for prop validation.

5. Generics in React
Generics are useful when you want to make components reusable with different types. 
For instance, a List component that can display different types of data:


import React from 'react';

type ListProps<T> = {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
};

function List<T>({ items, renderItem }: ListProps<T>): JSX.Element {
  return (
    <div>
      {items.map((item, index) => (
        <div key={index}>{renderItem(item)}</div>
      ))}
    </div>
  );
}

export const App = () => {
  return (
    <div>
      <List
        items={[1, 2, 3, 4]}
        renderItem={(item) => <p>{item}</p>}
      />
      <List
        items={['Apple', 'Banana', 'Cherry']}
        renderItem={(item) => <strong>{item}</strong>}
      />
    </div>
  );
};
Here, List is a generic component that can accept an array of any type (T). T
he renderItem function defines how each item is rendered, and TypeScript ensures
 type safety based on the array passed in items.



-----------------------------------------------------------

Redux

Redux is really:

A single store containing "global" state
Dispatching plain object actions to the store when something happens in the app
Pure reducer functions looking at those actions and returning immutably updated state

createStore to actually create a Redux store
combineReducers to combine multiple slice reducers into a single larger reducer
applyMiddleware to combine multiple middleware into a store enhancer
compose to combine multiple store enhancers into a single store enhancer


Demo
store=>Reducer=>state=>ui=>dispatch=>store
						Store:

							export const configureStore = (services) => createStore(
								reducers, 
								
							);


							index.js
							ReactDOM.render(
								<Provider store={configureStore(services)} context={ReactReduxContext} >
									<AuthComp />
									{/* <App /> */}
								</Provider>,
								document.getElementById('root')
							);


							Action

							export const getDataSuccess = result => ({
								type: GET_DATA_SUCCESS,
								payload: result,
							});


							Reducer
							const initialState = {
							  
								allData: [],
							   
							};

							const reducer = (state = initialState, action) => {
								switch (action.type) {
									case GET_DATA_SUCCESS:
										return { ...state, allData: action.payload, error: null };        
									default:
										return state;
								}
							}

							export default reducer;


							Selector

							export const getisEnable = state => state.home.isEnable;GET_DATA_SUCCESS

							Reducer index file

							const createRootReducer = (history) => combineReducers({
								router: connectRouter(history),
								ui,
								home,
								addNew,
								historyReducer,
								requestSearchSEReducer,
								multiSearchReducer
							})

							export default createRootReducer



							Dispatch
							  dispatch(getDataSuccess(result));

							Selector
							  const isEnable = useSelector(getisEnable);
  
  
  
 ---------------------------------------------------
  
  
 Redux toolkit
  
  Important Points:
-No need to action
-Vite is a build tool and development server designed to improve the development process of modern web applications. It does this by dividing your application modules into dependencies and source code. Dependencies are modules that do not change often, while source code is typically edited frequently during developmen
-configureStore(): wraps createStore to provide simplified configuration options and good defaults. It can automatically combine your slice reducers, adds whatever Redux middleware you supply, includes redux-thunk by default, and enables use of the Redux DevTools Extension.
-createReducer(): that lets you supply a lookup table of action types to case reducer functions, rather than writing switch statements. In addition, it automatically uses the immer library to let you write simpler immutable updates with normal mutative code, like state.todos[3].completed = true.
-createAction(): generates an action creator function for the given action type string. The function itself has toString() defined, so that it can be used in place of the type constant.
-createSlice(): accepts an object of reducer functions, a slice name, and an initial state value, and automatically generates a slice reducer with corresponding action creators and action types.
-createAsyncThunk: accepts an action type string and a function that returns a promise, and generates a thunk that dispatches pending/fulfilled/rejected action types based on that promise
-createEntityAdapter: generates a set of reusable reducers and selectors to manage normalized data in the store
-The createSelector utility from the Reselect library, re-exported for ease of use.
https://www.youtube.com/watch?v=2OaAbSgmIWo


-What do you understand about Redux Thunk?
-Using Redux Thunk middleware, we can write action creators returning a function instead of an action. This thunk can postpone the dispatch of an action, or do conditional dispatchment. The arguments passed to the inner function are the store methods dispatch and getState(). In the event of an action creator returning a function, the function gets executed by the Redux Thunk middleware and it does not have to be pure. In other words, the function is allowed to have side effects, including executing asynchronous API calls. It can even dispatch actions. Redux thunk is used to delay the dispatch of an action, or to dispatch in the event of a certain condition being met. At the time of dispatch of a function instead of an action object, if Redux Thunk middleware is enabled, the middleware will call that function with the dispatch method itself as the first argument.
-What are the workflow features in Redux?

Store
reducer -> need to change value
useselector
usedispatch


  
  Slice/Reducer
  
			  import { createSlice } from '@reduxjs/toolkit';

			export const counterSlice = createSlice({
			  name: 'counter',
			  initialState: {
				count: 0,
			  },
			  reducers: {
				increment: (state) => {
				  state.count += 1;
				},
				decrement: (state) => {
				  state.count -= 1;
				},
			  },
			});

			// Action creators are generated for each case reducer function
			export const { increment, decrement } = counterSlice.actions;

			export default counterSlice.reducer;
			
	Store
	
				import { configureStore } from '@reduxjs/toolkit';
			import counterReducer from '../features/counter/counterSlice';

			export const store = configureStore({
			  reducer: {
				counter: counterReducer,
			  },
});

	index,js
	ReactDOM.render(
	  <Provider store={store}>
		<App />
	  </Provider>,
	  document.getElementById('root')
	);
				 
	app.js
								import React from 'react';
			import { useSelector, useDispatch } from 'react-redux';
			import { increment, decrement } from './features/counter/counterSlice';

			function App() {
			  const count = useSelector((state) => state.counter.count);
			  const dispatch = useDispatch();

			  return (
				<div>
				  <h1>Counter: {count}</h1>
				  <button onClick={() => dispatch(increment())}>Increment</button>
				  <button onClick={() => dispatch(decrement())}>Decrement</button>
				</div>
			  );
			}

			export default App;
  
  
--------------------------------------------------------------------------------------------------------------


React
-------------------------------
Q=>difference between useCallback and useMemo 
		To summarize, the main difference between useCallback and useMemo is the type of value they return. useCallback returns 
		a memoized callback function, while useMemo returns a
		memoized value. Both hooks can be used to optimize the performance of your React components by avoiding unnecessary 
		re-creations of functions or values.
		
Q=>Use of Link and Nav link and diffrence between Link and Navlink
		we use link instad of <a> because a is refresh whole page so it's mot good way in reactLink is designed for use in SPAs,
		where navigation happens on the client side without reloading the page. 
		nav link use some extra feturn like in classname=> callback give is active class by default .
		<NavLink to="/about" activeClassName="active-link" activeStyle={{ fontWeight: 'bold' }}>
Q=>loader in react route:
it callback which allow to perfom opertion when u click route it's call before use effect
		https://medium.com/@younusraza909/loaders-in-react-router-71558c2988eb

	
	

Context api

context.js
=> var usecontext =   React.createContext( need to pass defult value)
export default usecontext


provider file


const [user,setuser] =React.usestate()
<usercontext.priovider value={{user,setuser}}>
{children}
</usercontext.priovider >


Login file
import UserContext  from 'context.js'

const {setUser} = useContext(UserContext)]



profile file
import UserContext  from 'context.js'

const {user} = useContext(UserContext)

React 18 

useId =>is a new Hook for generating unique IDs on both the client and server, while avoiding hydration mismatches. 
		const id = useId()
		
useTransition=>The use of Transition hooks allows us to specify certain state updates as less important
	if i have 3 tab about/post/contact and post have 2500 post then if i click
	post tab and click contact then contact not render untill post data comes
	so we use useTransition to reolve this issue
 
 const [isPending, startTransition] = useTransition()

useDeferredValue-The React.useDeferredValue() function is used to achieve asynchronous rendering. 
	-same as debounce which use for search like if i write one letter then it's call api insted
	of after 3,4 letter start seraching but react introduce hook same as debounce which help to
	perfomance 
	
	-useDeferredValue is a built-in hook in React that helps improve the performance
	of your application by deferring the re-rendering of some components when the value
	they depend on changes. It is particularly useful for handling high-priority UI updates while deferring 
	lower-priority updates that do not need to be immediate, thus preventing janky or slow interfaces.
	
 const deferredValue = useDeferredValue(value); 
 
useSyncExternalStore => (simple use case use your local variable and when add button 
						 value add we can achive using this)
					useSyncExternalStore is a hook introduced in React 18 to safely subscribe to external
					stores or state that are not controlled by React (e.g., external libraries, global 
					state management systems, or even custom stores). It is particularly useful when 
					dealing with shared state or managing subscriptions to data sources outside React.
					
					const state = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
					
					subscribe: A function that subscribes to an external store and allows React to be 
								notified when the store's state changes. It should accept a callback function
								and invoke that callback when the store updates.
					getSnapshot: A function that returns the current state from the store. 
								This function will be called to get the value that your component 
								should render.
					getServerSnapshot (optional): A function for server-side rendering (SSR). 
										It returns a snapshot of the state for rendering on the server, 
										which ensures the initial render is consistent when the component 
										mounts on the client.
										
								import React, { useState } from "react";
								import { useSyncExternalStore } from "react";

								// A simple external store (could be any external state management or library)
								let count = 0;
								const listeners = new Set<() => void>();

								// Function to get the current state (snapshot)
								const getCountSnapshot = () => count;

								// Function to subscribe to store updates
								const subscribeToStore = (callback: () => void) => {
								  listeners.add(callback);
								  // Return an unsubscribe function to remove the listener
								  return () => listeners.delete(callback);
								};

								// Function to update the store and notify subscribers
								const incrementCount = () => {
								  count += 1;
								  // Notify all subscribers when the state changes
								  listeners.forEach((listener) => listener());
								};

								const Counter: React.FC = () => {
								  // Use `useSyncExternalStore` to subscribe to the external store
								  const currentCount = useSyncExternalStore(subscribeToStore, getCountSnapshot);

								  return (
									<div>
									  <h1>Counter: {currentCount}</h1>
									  <button onClick={incrementCount}>Increment</button>
									</div>
								  );
								};

								export default Counter;

															
useimprativehandle:

				The useImperativeHandle hook in React is used to customize the instance
				value that is exposed when using React.forwardRef. This hook allows you to 
				explicitly define what methods or properties will be accessible to a parent component 
				when a child component is wrapped with forwardRef.

To allow a parent component to call specific methods or access properties of a child component.
To encapsulate internal details of a component and expose only what the parent needs.
To manipulate DOM elements or trigger child behaviors programmatically.

useImperativeHandle(ref, createHandle, [dependencies])
							ref: The forwarded ref from the parent component.
							createHandle: A function that returns an object containing the values/methods
											to expose to the parent.
							dependencies: (Optional) An array of dependencies that trigger a 
										re-creation of the exposed handle when they change.
										
										
										import React, { useState, forwardRef, useImperativeHandle } from "react";

											// Modal Component
											const Modal = forwardRef((props, ref) => {
											  const [isVisible, setIsVisible] = useState(false);

											  useImperativeHandle(ref, () => ({
												open: () => setIsVisible(true),
												close: () => setIsVisible(false),
											  }));

											  if (!isVisible) return null;

											  return (
												<div style={{ background: "rgba(0, 0, 0, 0.5)", padding: "20px" }}>
												  <p>{props.message || "This is a modal!"}</p>
												  <button onClick={() => setIsVisible(false)}>Close</button>
												</div>
											  );
											});

											// Parent Component
											const ParentComponent = () => {
											  const modalRef = useRef(null);

											  return (
												<div>
												  <button onClick={() => modalRef.current.open()}>Open Modal</button>
												  <Modal ref={modalRef} />
												</div>
											  );
											};

											export default ParentComponent;
											
useInsertionEffect =>useInsertionEffect allows inserting elements into the DOM before any layout
									Effects fire.
					useInsertionEffect is for CSS-in-JS library authors. Unless you are working on 
					a CSS-in-JS library 
					and need a place to inject the styles,
					 you probably want useEffect or useLayoutEffect instead.
useEffect:
	This is useful for side effects that don't need to interact with the DOM right after the render:
	Data fetching, subscriptions, timers
	For side effects that don't affect layout

useLayoutEffect:
	This is useful when you need to measure the layout or perform an effect that needs to be done 
	synchronously after the render but before the UI is painted
	DOM measurement, layout adjustments, animations
	For effects that need to manipulate or measure layout immediately after the render

=>suspense
=>Automatic batching
=>Userid ->The useId() hook is an easy way to generate a random and unique ID number in React 18
=>concurrent rendering
=>Server component
=>Portals in React
				Portals are a new concept in React 18 which allows you to render content in a different
				part of the DOM. 
				Portals are only supported on React 18.
						 return ReactDOM.createPortal(
			<h1>Portal demo</h1>,
			document.getElementById('portal')
		  )
		  
		  
=>Forword ref:

		when you use multiple input fileld with comman componenet so we need to pass refrence to 
		component in that case forword ref use

like common component name->inputfield
main component name- login
so we need to pass ref to inputfield to login component


React 19

=> include new compiler which compile react code
=>Automatic memoization
=>Document meta data
=>Ref pass as regular prop(no need to pass as forwordref)
=> no more react.lazy
=><context.provider> replace with <context>
Hooks
use()  -> replace useContext()
Action
useFormStatus()
useFormState()
useOptimistic(
)
]

useActionState
useCallback
useContext
useDebugValue
useLayoutEffect
useLayoutEffect
useMemo

Reconsilation


spred vs rest
use call back
Nextjs
------------------------
Intercepting Routes 
https://www.youtube.com/watch?v=zDZBKEvU8b0
Parallel Routes I
https://www.youtube.com/watch?v=wi8kF8UniUI
catch all
default
catch all vsdefault
Q=>what is Nextjs 
Next.js is a flexible React framework that gives you building blocks to create fast web applications.
CSR
SSR
SSG

Q=>What is imperative programming.
The code above is a good example of imperative programming. 
You’re writing the steps for how the user interface should be updated. 
But when it comes to building user interfaces, a declarative approach is often preferred because it can speed up the 
development process. Instead of having to write DOM methods, it would be helpful if developers were able to declare 
what they want to show (in this case, an h1 tag with some text).
In other words, imperative programming is like giving a chef step-by-step instructions on how to make a pizza. 
Declarative programming is like ordering a pizza without being concerned about the steps it takes to make the pizza. 🍕

Q=>environment
The environment where your code runs: Development vs. Production
When your code runs: Build Time vs. Runtime
Where rendering happens: Client vs. Server

Q=>Minification
Minification is the process of removing unnecessary code formatting and comments without changing the code’s functionality.
The goal is to improve the application’s performance by decreasing file sizes.


Q=>What is Compiling?
Developers write code in languages that are more developer-friendly such as JSX, TypeScript, and modern versions of JavaScript. 
While these languages improve the efficiency and confidence of developers, they need to be compiled into JavaScript before 
browsers can understand them.


Q=>What is Bundling?
Bundling is the process of resolving the web of dependencies and merging (or ‘packaging’) the files (or modules) into optimized 
bundles for the browser, with the goal of reducing the number of requests for files when a user visits a web page.

Q=>What is the difference between compiling and bundling in web development?
Compiling is transforming code into something parsable by browsers. 
Bundling is resolving your applications dependency graph and reducing the number of files

Q=>client-side rendering
in a standard React application, the browser receives an empty HTML shell from the server along with the JavaScript instructions 
to construct the UI. This is called client-side rendering because the initial rendering work happens on the user's device.

Q=>what is pre-rendering
In contrast, Next.js pre-renders every page by default. Pre-rendering means the HTML is generated in advance, 
on a server, instead of having it all done by JavaScript on the user's device.
In practice, this means that for a fully client-side rendered app, the user will see a blank page while the rendering work 
is being done. Compared to a pre-rendered app, where the user will see the constructed HTML:

Q=>server-side rendering
With server-side rendering, the HTML of the page is generated on a server for each request. The generated HTML, J
JSON data, and JavaScript instructions to make the page interactive are then sent to the client.

Q=>hydration
On the client, the HTML is used to show a fast non-interactive page, while React uses the JSON data and JavaScript 
instructions to make components interactive (for example, attaching event handlers to a button). This process is called hydration.

Q=>link In NExtjs
In Next.js, you can use the Link Component next/link to link between pages in your application. <Link> allows you to do 
client-side navigation and accepts props that give you better control over the navigation behavior.

Q=>Code splitting and prefetching
Next.js does code splitting automatically, so each page only loads what’s necessary for that page. That means when the homepage
is rendered, the code for other pages is not served initially.
This ensures that the homepage loads quickly even if you have hundreds of pages.
Only loading the code for the page you request also means that pages become isolated. 
If a certain page throws an error, the rest of the application would still work.
Furthermore, in a production build of Next.js, whenever Link components appear in the browser’s viewport, 
Next.js automatically prefetches the code for the linked page in the background.
By the time you click the link, the code for the destination page will already be loaded in the background, 
and the page transition will be near-instant!

Tailwind CSS.


Q=>Static Generation and Server-side Rendering
Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. 
The difference is in when it generates the HTML for a page.
=>Static Generation is the pre-rendering method that generates the HTML at build time. The pre-rendered HTML is then reused on each request.
=>Server-side Rendering is the pre-rendering method that generates the HTML on each request.

Q=>SWR
The team behind Next.js has created a React hook for data fetching called SWR. 
We highly recommend it if you’re fetching data on the client side. It handles caching, revalidation, focus tracking, 
refetching on interval, and more. We won’t cover the details here, but here’s an example usage:


First, we’ll create a page called [id].js under pages/posts. Pages that begin with [ and end with ] are dynamic routes in Next.js.

In pages/posts/[id].js, we’ll write code that will render a post page — just like other pages we’ve created.
Naming the file inside the route folder page.jsx transforms it into a UI route. 
This means that it will serve as a regular page with UI components. On the other hand, if you name the file as route.js,
it becomes an API route. This signifies that it will handle API requests and responses.

Q=>Server-side rendering methods in Next.js
Next.js provides several methods for rendering pages. Each of these methods serves a specific purpose and can be used in
different scenarios:

Static Site Generation (SSG): Static Generation is a server-side rendering method where Next.js generates HTML at build time. 
						      During the build process, Next.js fetches data from APIs or other data sources and pre-renders 
							  the HTML pages. These pre-rendered pages can then be served to the client upon request. 
							  SSG is suitable for websites with content that doesn't frequently change.
Server-Side Rendering (SSR): Server-Side Rendering is another method where Next.js generates HTML on each request. 
							When a user visits a page, Next.js fetches the data and renders the HTML on the server before 
							sending it to the client. SSR is useful for websites with frequently updated content or personalized 
							user experiences.
Incremental Static Regeneration (ISR): ISR is a feature in Next.js that allows you to statically generate pages on-demand,
									  rather than at build time. This means that your site can be both statically generated and
									  dynamic at the same time.



Q=>WHAT IS Routing
Routing as folder
each folder has page.js file.
The useRouter hook allows you to programmatically change routes.
This hook can only be used inside Client Components and is imported from next/navigation.
The useRouter hook allows you to programmatically change routes.
This hook can only be used inside Client Components and is imported from next/navigation.


Q=>WHAT IS NextResponse
The NextResponse API allows you to:
redirect the incoming request to a different URL
rewrite the response by displaying a given URL
Set request headers for API Routes, getServerSideProps, and rewrite destinations
Set response cookies
Set response headers
fetching data after some time  time based/ondemand  Revalidation

Q=>WHAT IS React Server Component Payload
React renders Server Components into a special data format called the React Server Component Payload (RSC Payload).

folder->page.tsx is used for routing
component like is not use for routing like add to cart button


Redux Thunk
Q=>What do you understand about Redux Thunk?
Using Redux Thunk middleware, we can write action creators returning a function instead of an action. 
This thunk can postpone the dispatch of an action, or do conditional dispatchment. The arguments passed to the inner function 
are the store methods dispatch and getState(). In the event of an action creator returning a function, the function gets 
executed by the Redux Thunk middleware and it does not have to be pure. In other words, the function is allowed to have side 
effects, including executing asynchronous API calls. It can even dispatch actions. Redux thunk is used to delay the dispatch of
 an action, or to dispatch in the event of a certain condition being met. At the time of dispatch of a function instead of an
 action object, if Redux Thunk middleware is enabled, the middleware will call that function with the dispatch method itself as 
 the first argument.

8. What are the workflow features in Redux?





"FORCE-DYNAMIC" force next js to load page dynamivally






Rest api
https://www.youtube.com/watch?v=-MFiza7ZRzs

https://www.freecodecamp.org/news/build-a-full-stack-application-with-nextjs/

--------------------------------------
@google-cloud/translate:

Google Cloud Translation API client for Node.js.
js
Copy code
const { Translate } = require('@google-cloud/translate').v2;
const translate = new Translate();

async function translateText(text) {
  const [translation] = await translate.translate(text, 'es');
  console.log(`Translation: ${translation}`);
}
translateText('Hello, world!');